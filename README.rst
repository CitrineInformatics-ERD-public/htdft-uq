htdft-uq
++++++++

Supporting datasets and scripts for the paper "Quantifying uncertainty in
high-throughput density functional theory: a comparison of AFLOW, Materials
Project, and OQMD", Hegde et al., arXiv:2007.01988 [cond-mat.mtrl-sci] (2020).
DOI: `10.48550/arXiv.2007.01988 <doi_>`_.

.. _doi: https://doi.org/10.48550/arXiv.2007.01988

The dataset of materials properties queried-and-aggregated from the three HT-DFT
databases, `AFLOW <aflow_>`_, `Materials Project <mp_>`_, and `OQMD <oqmd_>`_ is
`available in the data folder <agg-dataset_>`_.

.. _aflow: http://aflow.org
.. _mp: https://materialsproject.org
.. _oqmd: http://oqmd.org
.. _agg-dataset: data/DFTDB_extracted_props.json.gz


Python scripts to curate the queried-and-aggregated HT-DFT data as described in
the manuscript and to reproduce the results/analysis are also made available
(see details below).


Environment
===========
All non-standard packages are listed in the `requirements.txt`_ file.

.. _requirements.txt: requirements.txt


Data curation
=============

HT-DFT data queried-and-aggregated from the three databases mentioned above is
curated with the `1_curate_queried_data.py`_ script. Uses ``pymatgen`` for some
composition/chemical formula wrangling (`installation instructions here
<pymatgen_installation_>`_).

In order to perform a fair comparison between two HT-DFT databases, it is
essential to generate a set of equivalent records for each pair of databases
considered. We use the ICSD Collection Code(s) (hereafter, "ICSD ID(s)") in
the metadata of each entry to generate a set of comparable records.

The main text contains analysis only for records with the exact same ICSD ID
across the two databases being compared at a time, ensuring that the crystal
structure of the materials being compared are the same.
Since the ICSD ID of each material is retrieved as part of the metadata queried
from each of the three HT-DFT databases, materials can be matched across
databases by directly comparing their ICSD IDs.

Since the former process of exact ICSD ID matching results in a smaller set of
records (less than 50%) when compared to the total ICSD entries in each
database, we investigated if our results hold on a larger comparison set
generated by linking similar ICSD entries. For the process of linking similar
ICSD entries, we use the structure comparison and matching algorithm implemented
within the Materials Project.

Note that the latter curation of data
to generate the larger comparison set is done by corresponding scripts in the
`multi-icsd-id-data`_ folder.

.. _multi-icsd-id-data: multi-icsd-id-data

Overall the various curation steps are as follows:


Annotation of extracted data with "ICSD UID"
--------------------------------------------

This step involves the following two subtasks:

1. Generation of a set of ICSD UIDs from Materials Project:

   An ICSD UID is
   defined as a set of ICSD Collection Codes (ICSD IDs) belonging to the same
   material. The Materials Project already groups ICSD IDs per material, but due
   to the affine mapping based structure matching implemented (*J. Appl.
   Cryst.* **39**, 6-16 (2006) DOI: `10.1107/S0021889805032450
   <affine_doi_>`_), the material can be part of two different "groups of
   equivalent structures". For example, there are three different records for
   AgO in Materials Project that share the ICSD ID 60625. This task in the
   curation pipeline thus aggregates the ICSD IDs from all three such records to
   generate a "super" ICSD UID.

.. _affine_doi: https://doi.org/10.1107/S0021889805032450

2. Annotation of extracted records with an ICSD UID:

   First, every record retrieved from Materials Project is matched to an ICSD
   UID from the set above, depending on the ICSD IDs in the record (the set of
   ICSD IDs in the record will be a subset of exactly one ICSD UID). Second, it
   is attempted to match every record retrieved from AFLOW and OQMD to ICSD UID.
   If no match is found, the ICSD ID in such a record constitutes a new ICSD
   UID.

The extracted properties dictionary at this step looks similar to:

.. code:: text

     {
          AFLOW: [
            {
               db_id: 1,
               prop_name_1: prop_val_1,
               prop_name_2: prop_val_2,
               icsd_uid: icsd_id_1--icsd_id_6--icsd_id_7,
               ...
            },
            {
               db_id: 2,
               icsd_uid: icsd_id_2--icsd_id_3,
               ...
            },
            {
               db_id: 3,
               icsd_uid: icsd_id_1--icsd_id_6--icsd_id_7,
               ...
            },
            ...
            ...
          ],

          MP: [
            ...
            ...
          ],
       ...
       ...
     }


(Reverse-)mapping properties to ICSD UIDs
-----------------------------------------

This step involves "inverting" the dictionary of extracted properties above
such that the ICSD UIDs are the keys and a list of data records corresponding
to each UID is the value.

The inverted dictionary at this step is written to a gzipped archive
`DFTDB_ICSD_UID_raw_inv_data.json.gz`_, and looks similar to:

.. code:: text

     {
         AFLOW: {
           icsd_id_1--icsd_id_6--icsd_id_7: [
             {
                db_id: 1,
                prop_name_1: prop_val_1,
                prop_name_2: prop_val_2,
             },
             {
                db_id: 3,
                ...
             }
           ],
           icsd_id_2--icsd_id_3: [
             {
                db_id: 2,
                ...
             }
           ],
         },

         MP: {
           ...
           ...
         },
       ...
       ...
     }



Removing composition inconsistencies
------------------------------------

From the ICSD UID to properties dictionary above, an ICSD UID key is removed if
the entries within it do not have matching compositions. This process is done
first within each of the three databases, and then for UIDs common to pair-wise
combinations of the databases.

Most records filtered out at this step are materials with different number of H
and Li atoms (e.g., BaGaH4 vs BaGaH5) or small changes in composition (e.g.,
Y3Fe29 vs Y3Fe31).


Filtering for the lowest energy entry per ICSD UID
--------------------------------------------------

For each ICSD UID, since there may exist multiple entries (calculations) in
every database, only the entry with the lowest ``total_energy_per_atom`` value
is retained from this step onward.


Removing records with unphysical properties
-------------------------------------------

At this step, any records with unphysical values of certain properties are
removed. This includes all boride formation energies from AFLOW, due to an
error in the B chemical potential (according to private communication with the
AFLOW developers). Beyond AFLOW borides, unphysical properties are defined as
per-atom formation energies outside -5 to +5 eV/atom, per-atom volumes above
150 Angstrom/atom, for all three databases.


Convert all per-atom magnetization into absolute values
-------------------------------------------------------

Finally, all ``total_magnetization_per_atom`` values in all three databases are
converted into absolute values.

The final curated data is written into a gzipped archive
`DFTDB_ICSD_UID_curated_data.json.gz`_.

.. _1_curate_queried_data.py: 1_curate_queried_data.py
.. _pymatgen_installation: https://pymatgen.org/#getting-pymatgen
.. _DFTDB_ICSD_UID_raw_inv_data.json.gz: data/DFTDB_ICSD_UID_raw_inv_data.json.gz
.. _DFTDB_ICSD_UID_curated_data.json.gz: data/DFTDB_ICSD_UID_curated_data.json.gz


Data analysis
=============

The following Python scripts implement the analysis described in the manuscript
(note that the files generated in the curation steps described above are
**required** by these analysis scripts):

1. `2a_get_records_per_curation_step.py`_: As the names suggests, this script
records the entries from each HT-DFT database that were filtered out in each
curation step detailed above, and writes them to files in the `data folder`_.
For example, the entries from each database that were filtered out for having
within-database composition discrepancies are written to the
``data/comp_mm_within_db.json`` file.

.. _2a_get_records_per_curation_step.py: 2a_get_records_per_curation_step.py
.. _data folder: data

2. `2b_get_per_element_stats.py`_: This script gathers the statistics of
materials properties for each HT-DFT database as a function of each element of
the periodic table. That is, it records, for each element in the periodic table,
statistics such as: how many formation energy calculations are present in the
Materials Project containing that element? what is the mean/median/other
formation energy of all materials containing that element? and so on. Similarly,
it gathers such statistics for each pair-wise comparison of HT-DFT databases
(i.e., across all comparable records in the two databases being compared). It
writes the per-element statistics into ``data/elem_stats_per_db.json`` and
``data/elem_stats_per_pair.json`` files, respectively.

.. _2b_get_per_element_stats.py: 2b_get_per_element_stats.py

3. `2c_get_per_material_class_stats.py`_: This script (1) categorizes (and
collects) entries in the set of comparable records for each pair-wise comparison
of HT-DFT databases into "materials classes", and (2) calculates statistics such
as tally, mean, median, median absolute difference, pearson correlation, and
others, for each materials class. A list of the materials classes defined in
this work can be found in `this file <matcls-file_>`_. The property thresholds
for classifying a material as a "metal"/"semiconductor"/"insulator", and as "has
magnetic moment" can be found in `this file <clscrit-file_>`_. The
implementation for classifying each material, including cases such as "the two
databases being compared disagree on whether this material has a non-zero band
gap", is in the `classify_material_utils`_ module. It writes the
per-material-class statistics into ``data/pmc_data.json`` and
``data/pmc.stats.json`` files. Note that the former file can be quite large!
Close to 400M in size (and ~620M for the ``multi-icsd-id-data`` case).

.. _2c_get_per_material_class_stats.py: 2c_get_per_material_class_stats.py
.. _matcls-file: config/MATERIAL_CLASSES.json
.. _clscrit-file: config/CLASSIFY_CRITERIA.json
.. _classify_material_utils: utils/classify_material_utils.py
